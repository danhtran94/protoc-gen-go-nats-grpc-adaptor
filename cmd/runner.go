package cmd

import (
	"fmt"
	"log/slog"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
)

// Run starts running the plugin
func Run() error {
	protogen.Options{}.Run(
		func(gen *protogen.Plugin) error {
			for _, file := range gen.Files {
				if !file.Generate {
					continue
				}
				if err := generateFile(gen, file); err != nil {
					return err
				}
			}
			return nil
		},
	)
	return nil
}

const templ = `
// Code generated by protoc-gen-go-nats-grpc-adaptor. DO NOT EDIT.
// source: {{.GeneratedFilenamePrefix}}.proto

package {{.GoPackageName}}

{{ formatImports .Imports }}

var tracer = otel.Tracer("{{ .Proto.Name }}")

// handleError is a helper which response with the error.
func handleError(req micro.Request, err error) {
	if sendErr := req.Error("500", err.Error(), nil); sendErr != nil {
		slog.Error(
			"error sending response error",
			slog.String("reason", sendErr.Error()),
			slog.String("subject", req.Subject()),
		)
	}
}

{{ range .Services }}

// NewNATS{{ .GoName }}Server returns the gRPC server as a NATS micro service.
func NewNATS{{ .GoName }}Server(ctx context.Context, nc *nats.Conn, server {{ .GoName }}Server, version, queueGroup string) (micro.Service, error) {
    cfg := micro.Config{
    	Name: "{{ .GoName }}Server",
        Version: version,
        QueueGroup: queueGroup,
        Description: "NATS micro service adaptor wrapping {{ .GoName }}Server",
    }

    srv, err := micro.AddService(nc, cfg)
    if err != nil {
        return nil, err
    }

    logger := slog.With(
     	slog.Group(
      		"service",
        	slog.String("name", cfg.Name),
       		slog.String("version", cfg.Version),
       		slog.String("queue-group", cfg.QueueGroup),
      	),
    )

    {{ range .Methods }}
    logger.Info(
    	"registring endpoint",
     	slog.Group(
      		"endpoint",
        	slog.String("subject", strings.ToLower("svc.{{ .Parent.GoName }}.{{ .GoName }}")),
      	),
    )

    err = srv.AddEndpoint(
        "{{ .Parent.GoName }}",
        micro.ContextHandler(
        	ctx,
        	func(ctx context.Context, req micro.Request){
         		endpointSubject := strings.ToLower("svc.{{ .Parent.GoName }}.{{ .GoName }}")

         		ctx, span := tracer.Start(ctx, "{{ .GoName }}", trace.WithAttributes(attribute.String("subject", endpointSubject)))
           		defer span.End()

	            hlogger := logger.With(
	              	slog.Group(
	               		"endpoint",
	                		slog.String("subject", endpointSubject),
	               	),
	             )

				/*
					Playing around with pulling out information

					{{ .Input.Desc.Parent.Path }}
					{{ .Input.Desc.Parent.Package }}
					{{ .Input.GoIdent.GoImportPath }}.{{ .Input.GoIdent.GoName }}{}
				*/

         		r := &{{ .Input.GoIdent.GoName }}{}

           		/*
             		Unmarshal the request.
             	*/
         		if err := googleProto.Unmarshal(req.Data(), r); err != nil {
           			hlogger.Error("unmarshaling request", slog.String("reason", err.Error()))
           			handleError(req, err)
                	return
                }

                /*
                	Forward on the original request to the original gRPC service.
                */
                resp, err := server.{{ .GoName }}(ctx, r)
                if err != nil {
             		hlogger.Error("service error", slog.String("reason", err.Error()))
             		handleError(req, err)
               		return
                }

                /*
                	Take the response from the gRPC service and dump it as a byte array.
                */
                respDump, err := googleProto.Marshal(resp)
                if err != nil {
              		hlogger.Error("marshaling response", slog.String("reason", err.Error()))
              		handleError(req, err)
                	return
                }

                /*
                	Finally response with the original response from the gRPC service.
                */
                if err := req.Respond(respDump); err != nil {
              		hlogger.Error("sending response", slog.String("reason", err.Error()))
              		handleError(req, err)
                	return
                }
         	},
        ),
        micro.WithEndpointSubject(strings.ToLower("svc.{{ .Parent.GoName }}.{{ .GoName }}")),
        micro.WithEndpointMetadata(map[string]string{"Description": "TODO: still to be implemented - see .proto file for doco"}),
    )

    if err != nil {
    	logger.Error(
     		"registering endpoint",
       		slog.Group(
         		"endpoint",
           		slog.String("subject", strings.ToLower("svc.{{ .Parent.GoName }}.{{ .GoName }}")),
         	),
       		slog.String("reason", err.Error()),
        )
        return nil, err
    }
    {{ end }}

    return srv, nil
}

// NATS{{ .GoName }}Client is a client connecting to a NATS {{ .GoName }}Server.
type NATS{{ .GoName }}Client struct {
	nc *nats.Conn
}

// NewNATS{{ .GoName }}Client returns a new {{ .GoName }}Server client.
func NewNATS{{ .GoName }}Client(nc *nats.Conn) *NATS{{ .GoName }}Client {
	return &NATS{{ .GoName }}Client{
		nc: nc,
	}
}

{{ range .Methods }}
{{ .Comments.Leading }}func (c *NATS{{ .Parent.GoName }}Client) {{ .GoName }}(ctx context.Context, req *{{ .Input.GoIdent.GoName }}) (*{{ .Output.GoIdent.GoName }}, error) {
	subject := strings.ToLower("svc.{{ .Parent.GoName }}.{{ .GoName }}")

	ctx, span := tracer.Start(ctx, "{{ .GoName }}", trace.WithAttributes(attribute.String("subject", subject)))
	defer span.End()

	payload, err := googleProto.Marshal(req)
	if err != nil {
		return nil, err
	}

	respPayload, err := c.nc.RequestWithContext(ctx, subject, payload)
	if err != nil {
		return nil, err
	}

	rpcError := respPayload.Header.Get(micro.ErrorHeader)
	if rpcError != "" {
		return nil, errors.New(rpcError)
	}

	resp := &{{ .Output.GoIdent.GoName }}{}
	if err := googleProto.Unmarshal(respPayload.Data, resp); err != nil {
		return nil, err
	}

	return resp, nil
}
{{ end }}

{{ end }}

`

// Import represents a package import
type Import struct {
	Path string
	Name string
}

// formatImports formats a list of imports properly
func formatImports(imports []Import) string {
	if len(imports) == 0 {
		return ""
	}

	var result strings.Builder
	result.WriteString("import (\n")
	for _, imp := range imports {
		if imp.Name != "" {
			result.WriteString(fmt.Sprintf("\t%s %q\n", imp.Name, imp.Path))
		} else {
			result.WriteString(fmt.Sprintf("\t%q\n", imp.Path))
		}
	}
	result.WriteString(")")
	return result.String()
}

// getRequiredImports returns the list of required imports for the template
func getRequiredImports() []Import {
	return []Import{
		{Path: "context"},
		{Path: "log/slog"},
		{Path: "strings"},
		{Path: "errors"},
		{Path: "google.golang.org/protobuf/proto", Name: "googleProto"},
		{Path: "github.com/nats-io/nats.go", Name: "nats"},
		{Path: "github.com/nats-io/nats.go/micro", Name: "micro"},
		{Path: "go.opentelemetry.io/otel"},
		{Path: "go.opentelemetry.io/otel/attribute"},
		{Path: "go.opentelemetry.io/otel/trace"},
	}
}

func collectProtoImports(file *protogen.File) []Import {
	imports := make(map[string]struct{}) // Use map to deduplicate imports

	// Process each dependency of the file
	for _, dep := range file.Proto.Dependency {
		slog.Debug("file dependency", slog.Any("file", dep))
		if imp := file.GoImportPath; imp != "" {
			imports[string(imp)] = struct{}{}
		}
	}

	var processMessage func(message *protogen.Message)
	processMessage = func(message *protogen.Message) {
		for _, field := range message.Fields {
			// Handle message types
			if field.Message != nil {
				if imp := field.Message.GoIdent.GoImportPath; imp != "" && imp != file.GoImportPath {
					imports[string(imp)] = struct{}{}
				}
			}

			// Handle enum types
			if field.Enum != nil {
				if imp := field.Enum.GoIdent.GoImportPath; imp != "" && imp != file.GoImportPath {
					imports[string(imp)] = struct{}{}
				}
			}
		}

		// Process nested messages
		for _, nested := range message.Messages {
			processMessage(nested)
		}
	}

	// Process all messages
	for _, message := range file.Messages {
		processMessage(message)
	}

	// Process services
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if method.Input != nil {
				if imp := method.Input.GoIdent.GoImportPath; imp != "" && imp != file.GoImportPath {
					imports[string(imp)] = struct{}{}
				}
			}
			if method.Output != nil {
				if imp := method.Output.GoIdent.GoImportPath; imp != "" && imp != file.GoImportPath {
					imports[string(imp)] = struct{}{}
				}
			}
		}
	}

	// Convert map to slice of Import
	var result []Import
	for importPath := range imports {
		if importPath == "" || importPath == string(file.GoImportPath) {
			continue
		}
		result = append(result, Import{Path: importPath})
	}

	return result
}

// generateFile generates a .pb.go file.
func generateFile(gen *protogen.Plugin, file *protogen.File) error {
	// Create template functions map
	funcMap := template.FuncMap{
		"formatImports": formatImports,
	}

	tmpl, err := template.New("nats-micro-service").Funcs(funcMap).Parse(templ)
	if err != nil {
		return err
	}

	if len(file.Services) == 0 {
		// nothing to do here - no services found in this file.
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "-nats-grpc-adaptor.pb.go"
	logger := slog.With("filename", filename)
	logger.Info("generating the files")

	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// Get required imports and proto imports
	requiredImports := getRequiredImports()
	protoImports := collectProtoImports(file)

	// Combine all imports
	allImports := append(requiredImports, protoImports...)

	// Create template data structure
	data := struct {
		*protogen.File
		Imports []Import
	}{
		File:    file,
		Imports: allImports,
	}

	if err := tmpl.Execute(g, data); err != nil {
		logger.Error("failed to execute the template", slog.String("reason", err.Error()))
		return err
	}

	return nil
}
