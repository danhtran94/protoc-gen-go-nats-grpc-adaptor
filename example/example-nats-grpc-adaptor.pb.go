// Code generated by protoc-gen-go-nats-grpc-adaptor. DO NOT EDIT.
// source: example.proto

package example

import (
	"log/slog"
	googleProto "google.golang.org/protobuf/proto"
	nats "github.com/nats-io/nats.go"
	micro "github.com/nats-io/nats.go/micro"
	"strings"
	"errors"
	"google.golang.org/protobuf/types/known/structpb"
	"context"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

var tracer = otel.Tracer("example.proto")

// handleError is a helper which response with the error.
func handleError(req micro.Request, err error) {
	if sendErr := req.Error("500", err.Error(), nil); sendErr != nil {
		slog.Error(
			"error sending response error",
			slog.String("reason", sendErr.Error()),
			slog.String("subject", req.Subject()),
		)
	}
}

// JobHandler is job handler for the concurrent service.
type JobHandler struct {
	ctx     context.Context
	execute func(context.Context, micro.Request)
	msg     micro.Request
}

// ConcurrentService is a wrapper around the micro.Service interface, extending with additional functionality.
type ConcurrentService struct {
	micro micro.Service
	jobs  chan (JobHandler)
}

// AddEndpoint registers endpoint with given name on a specific subject.
func (m *ConcurrentService) AddEndpoint(name string, handler micro.Handler, opts ...micro.EndpointOpt) error {
	return m.micro.AddEndpoint(name, handler, opts...)
}

// AddGroup returns a Group interface, allowing for more complex endpoint topologies.
// A group can be used to register endpoints with given prefix.
func (m *ConcurrentService) AddGroup(group string, opts ...micro.GroupOpt) micro.Group {
	return m.micro.AddGroup(group)
}

// Info returns the service info.
func (m *ConcurrentService) Info() micro.Info {
	return m.micro.Info()
}

// Stats returns statistics for the service endpoint and all monitoring endpoints.
func (m *ConcurrentService) Stats() micro.Stats {
	return m.micro.Stats()
}

// Reset resets all statistics (for all endpoints) on a service instance.
func (m *ConcurrentService) Reset() {
	m.micro.Reset()
}

// Stop drains the endpoint subscriptions and marks the service as stopped.
func (m *ConcurrentService) Stop() error {
	close(m.jobs)
	return m.micro.Stop()
}

// Stopped informs whether [Stop] was executed on the service.
func (m *ConcurrentService) Stopped() bool {
	return m.micro.Stopped()
}

// ConcurrentServiceOption is a function used to configure a ConcurrentService.
type ConcurrentServiceOption func(*ConcurrentService)

// WithConcurrentJobs sets the number of concurrent jobs to be executed.
func WithConcurrentJobs(jobs int) ConcurrentServiceOption {
	return func(s *ConcurrentService) {
		s.jobs = make(chan JobHandler, jobs)
		for i := 0; i < jobs; i++ {
			go func() {
				for job := range s.jobs {
					slog.Info("executing job", slog.Int("worker", i))
					job.execute(job.ctx, job.msg)
				}
			}()
		}
	}
}

// NewNATSGreeterServer returns the gRPC server as a NATS micro service.
//
// Example:
//
//	nc, err := nats.Connect(ns.ClientURL())
//	if err != nil {
//	  panic(err)
//	}
//
//	cfg := micro.Config{
//	    Name: "GreeterServer-Demo",
//	    Version: "1.0.0",
//	    QueueGroup: "example",
//	    Description: "NATS micro service adaptor wrapping GreeterServer",
//	}
//
//	mc, err := NewNATSGreeterServer(context.Background(), nc, GreeterService{}, cfg)
//	if err != nil {
//	  panic(err)
//	}
//
//	fmt.Printf("%s -> %s\n", mc.Info().Name, mc.Info().ID)
func NewNATSGreeterServer(ctx context.Context, nc *nats.Conn, server GreeterServer, cfg micro.Config, opts ...ConcurrentServiceOption) (micro.Service, error) {
	srv, err := micro.AddService(nc, cfg)
	if err != nil {
		return nil, err
	}

	concurrentSrv := &ConcurrentService{
		jobs: make(chan JobHandler, 1),
	}

	for _, opt := range opts {
		opt(concurrentSrv)
	}

	concurrentSrv.micro = srv

	logger := slog.With(
		slog.Group(
			"service",
			slog.String("name", cfg.Name),
			slog.String("version", cfg.Version),
			slog.String("queue-group", cfg.QueueGroup),
			slog.Int("workers", cap(concurrentSrv.jobs)),
		),
	)

	logger.Info(
		"registring endpoint",
		slog.Group(
			"endpoint",
			slog.String("subject", cfg.Name+"."+strings.ToLower("svc.Greeter.SayHello")),
		),
	)

	err = srv.AddEndpoint(
		"Greeter",
		micro.ContextHandler(
			ctx,
			func(ctx context.Context, req micro.Request) {
				handler := func(ctx context.Context, req micro.Request) {
					endpointSubject := cfg.Name + "." + strings.ToLower("svc.Greeter.SayHello")

					ctx, span := tracer.Start(ctx, "SayHello", trace.WithAttributes(attribute.String("subject", endpointSubject)))
					defer span.End()

					hlogger := logger.With(
						slog.Group(
							"endpoint",
							slog.String("subject", endpointSubject),
						),
					)

					r := new(HelloRequest)

					if err := googleProto.Unmarshal(req.Data(), r); err != nil {
						hlogger.Error("unmarshaling request", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					resp, err := server.SayHello(ctx, r)
					if err != nil {
						hlogger.Error("service error", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					respDump, err := googleProto.Marshal(resp)
					if err != nil {
						hlogger.Error("marshaling response", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					if err := req.Respond(respDump); err != nil {
						hlogger.Error("sending response", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}
				}

				concurrentSrv.jobs <- JobHandler{ctx, handler, req}
			},
		),
		micro.WithEndpointSubject(cfg.Name+"."+strings.ToLower("svc.Greeter.SayHello")),
		micro.WithEndpointMetadata(map[string]string{"Description": "TODO: still to be implemented - see .proto file for doco"}),
	)

	logger.Info(
		"registring endpoint",
		slog.Group(
			"endpoint",
			slog.String("subject", cfg.Name+"."+strings.ToLower("svc.Greeter.SayHelloAgain")),
		),
	)

	err = srv.AddEndpoint(
		"Greeter",
		micro.ContextHandler(
			ctx,
			func(ctx context.Context, req micro.Request) {
				handler := func(ctx context.Context, req micro.Request) {
					endpointSubject := cfg.Name + "." + strings.ToLower("svc.Greeter.SayHelloAgain")

					ctx, span := tracer.Start(ctx, "SayHelloAgain", trace.WithAttributes(attribute.String("subject", endpointSubject)))
					defer span.End()

					hlogger := logger.With(
						slog.Group(
							"endpoint",
							slog.String("subject", endpointSubject),
						),
					)

					r := new(HelloRequest)

					if err := googleProto.Unmarshal(req.Data(), r); err != nil {
						hlogger.Error("unmarshaling request", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					resp, err := server.SayHelloAgain(ctx, r)
					if err != nil {
						hlogger.Error("service error", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					respDump, err := googleProto.Marshal(resp)
					if err != nil {
						hlogger.Error("marshaling response", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					if err := req.Respond(respDump); err != nil {
						hlogger.Error("sending response", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}
				}

				concurrentSrv.jobs <- JobHandler{ctx, handler, req}
			},
		),
		micro.WithEndpointSubject(cfg.Name+"."+strings.ToLower("svc.Greeter.SayHelloAgain")),
		micro.WithEndpointMetadata(map[string]string{"Description": "TODO: still to be implemented - see .proto file for doco"}),
	)

	logger.Info(
		"registring endpoint",
		slog.Group(
			"endpoint",
			slog.String("subject", cfg.Name+"."+strings.ToLower("svc.Greeter.SayGoodbye")),
		),
	)

	err = srv.AddEndpoint(
		"Greeter",
		micro.ContextHandler(
			ctx,
			func(ctx context.Context, req micro.Request) {
				handler := func(ctx context.Context, req micro.Request) {
					endpointSubject := cfg.Name + "." + strings.ToLower("svc.Greeter.SayGoodbye")

					ctx, span := tracer.Start(ctx, "SayGoodbye", trace.WithAttributes(attribute.String("subject", endpointSubject)))
					defer span.End()

					hlogger := logger.With(
						slog.Group(
							"endpoint",
							slog.String("subject", endpointSubject),
						),
					)

					r := new(SayGoodbyeRequest)

					if err := googleProto.Unmarshal(req.Data(), r); err != nil {
						hlogger.Error("unmarshaling request", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					resp, err := server.SayGoodbye(ctx, r)
					if err != nil {
						hlogger.Error("service error", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					respDump, err := googleProto.Marshal(resp)
					if err != nil {
						hlogger.Error("marshaling response", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					if err := req.Respond(respDump); err != nil {
						hlogger.Error("sending response", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}
				}

				concurrentSrv.jobs <- JobHandler{ctx, handler, req}
			},
		),
		micro.WithEndpointSubject(cfg.Name+"."+strings.ToLower("svc.Greeter.SayGoodbye")),
		micro.WithEndpointMetadata(map[string]string{"Description": "TODO: still to be implemented - see .proto file for doco"}),
	)

	logger.Info(
		"registring endpoint",
		slog.Group(
			"endpoint",
			slog.String("subject", cfg.Name+"."+strings.ToLower("svc.Greeter.SaveMetadata")),
		),
	)

	err = srv.AddEndpoint(
		"Greeter",
		micro.ContextHandler(
			ctx,
			func(ctx context.Context, req micro.Request) {
				handler := func(ctx context.Context, req micro.Request) {
					endpointSubject := cfg.Name + "." + strings.ToLower("svc.Greeter.SaveMetadata")

					ctx, span := tracer.Start(ctx, "SaveMetadata", trace.WithAttributes(attribute.String("subject", endpointSubject)))
					defer span.End()

					hlogger := logger.With(
						slog.Group(
							"endpoint",
							slog.String("subject", endpointSubject),
						),
					)

					r := new(structpb.Struct)

					if err := googleProto.Unmarshal(req.Data(), r); err != nil {
						hlogger.Error("unmarshaling request", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					resp, err := server.SaveMetadata(ctx, r)
					if err != nil {
						hlogger.Error("service error", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					respDump, err := googleProto.Marshal(resp)
					if err != nil {
						hlogger.Error("marshaling response", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}

					if err := req.Respond(respDump); err != nil {
						hlogger.Error("sending response", slog.String("reason", err.Error()))
						handleError(req, err)
						return
					}
				}

				concurrentSrv.jobs <- JobHandler{ctx, handler, req}
			},
		),
		micro.WithEndpointSubject(cfg.Name+"."+strings.ToLower("svc.Greeter.SaveMetadata")),
		micro.WithEndpointMetadata(map[string]string{"Description": "TODO: still to be implemented - see .proto file for doco"}),
	)

	return srv, nil
}

// NewNATSGRPCClientToGreeterServer returns the gRPC server wrapping a gRPC client as a NATS micro service.
//
// Example:
//
//	nc, err := nats.Connect(ns.ClientURL())
//	if err != nil {
//	  panic(err)
//	}
//
//	var opts := []grpc.DailOption
//
//	conn, err := grpc.NewClient("localhost:1234", opts...)
//	if err != nil {
//	    panic(err)
//	}
//
//	defer conn.Close()
//
//	client := NewGreeterClient(conn)
//
//	cfg := micro.Config{
//	    Name: "GreeterWrapper-Demo",
//	    Version: "1.0.0",
//	    QueueGroup: "example",
//	    Description: "NATS micro service adaptor wrapping GreeterClient",
//	}
//
//	mc, err := NewNATSGRPCClientToGreeterServer(context.Background(), nc, client, cfg)
//	if err != nil {
//	  panic(err)
//	}
//
//	fmt.Printf("%s -> %s\n", mc.Info().Name, mc.Info().ID)
func NewNATSGRPCClientToGreeterServer(ctx context.Context, nc *nats.Conn, client GreeterClient, cfg micro.Config) (micro.Service, error) {
	srv, err := micro.AddService(nc, cfg)
	if err != nil {
		return nil, err
	}

	logger := slog.With(
		slog.Group(
			"service",
			slog.String("name", cfg.Name),
			slog.String("version", cfg.Version),
			slog.String("queue-group", cfg.QueueGroup),
		),
	)

	logger.Info(
		"registring endpoint",
		slog.Group(
			"endpoint",
			slog.String("subject", cfg.Name+"."+strings.ToLower("svc.Greeter.SayHello")),
		),
	)

	err = srv.AddEndpoint(
		"Greeter",
		micro.ContextHandler(
			ctx,
			func(ctx context.Context, req micro.Request) {
				endpointSubject := cfg.Name + "." + strings.ToLower("svc.Greeter.SayHello")

				ctx, span := tracer.Start(ctx, "SayHello", trace.WithAttributes(attribute.String("subject", endpointSubject)))
				defer span.End()

				hlogger := logger.With(
					slog.Group(
						"endpoint",
						slog.String("subject", endpointSubject),
					),
				)

				r := new(HelloRequest)

				if err := googleProto.Unmarshal(req.Data(), r); err != nil {
					hlogger.Error("unmarshaling request", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				resp, err := client.SayHello(ctx, r)
				if err != nil {
					hlogger.Error("service error", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				respDump, err := googleProto.Marshal(resp)
				if err != nil {
					hlogger.Error("marshaling response", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				if err := req.Respond(respDump); err != nil {
					hlogger.Error("sending response", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}
			},
		),
		micro.WithEndpointSubject(cfg.Name+"."+strings.ToLower("svc.Greeter.SayHello")),
		micro.WithEndpointMetadata(map[string]string{"Description": "TODO: still to be implemented - see .proto file for doco"}),
	)

	logger.Info(
		"registring endpoint",
		slog.Group(
			"endpoint",
			slog.String("subject", cfg.Name+"."+strings.ToLower("svc.Greeter.SayHelloAgain")),
		),
	)

	err = srv.AddEndpoint(
		"Greeter",
		micro.ContextHandler(
			ctx,
			func(ctx context.Context, req micro.Request) {
				endpointSubject := cfg.Name + "." + strings.ToLower("svc.Greeter.SayHelloAgain")

				ctx, span := tracer.Start(ctx, "SayHelloAgain", trace.WithAttributes(attribute.String("subject", endpointSubject)))
				defer span.End()

				hlogger := logger.With(
					slog.Group(
						"endpoint",
						slog.String("subject", endpointSubject),
					),
				)

				r := new(HelloRequest)

				if err := googleProto.Unmarshal(req.Data(), r); err != nil {
					hlogger.Error("unmarshaling request", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				resp, err := client.SayHelloAgain(ctx, r)
				if err != nil {
					hlogger.Error("service error", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				respDump, err := googleProto.Marshal(resp)
				if err != nil {
					hlogger.Error("marshaling response", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				if err := req.Respond(respDump); err != nil {
					hlogger.Error("sending response", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}
			},
		),
		micro.WithEndpointSubject(cfg.Name+"."+strings.ToLower("svc.Greeter.SayHelloAgain")),
		micro.WithEndpointMetadata(map[string]string{"Description": "TODO: still to be implemented - see .proto file for doco"}),
	)

	logger.Info(
		"registring endpoint",
		slog.Group(
			"endpoint",
			slog.String("subject", cfg.Name+"."+strings.ToLower("svc.Greeter.SayGoodbye")),
		),
	)

	err = srv.AddEndpoint(
		"Greeter",
		micro.ContextHandler(
			ctx,
			func(ctx context.Context, req micro.Request) {
				endpointSubject := cfg.Name + "." + strings.ToLower("svc.Greeter.SayGoodbye")

				ctx, span := tracer.Start(ctx, "SayGoodbye", trace.WithAttributes(attribute.String("subject", endpointSubject)))
				defer span.End()

				hlogger := logger.With(
					slog.Group(
						"endpoint",
						slog.String("subject", endpointSubject),
					),
				)

				r := new(SayGoodbyeRequest)

				if err := googleProto.Unmarshal(req.Data(), r); err != nil {
					hlogger.Error("unmarshaling request", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				resp, err := client.SayGoodbye(ctx, r)
				if err != nil {
					hlogger.Error("service error", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				respDump, err := googleProto.Marshal(resp)
				if err != nil {
					hlogger.Error("marshaling response", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				if err := req.Respond(respDump); err != nil {
					hlogger.Error("sending response", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}
			},
		),
		micro.WithEndpointSubject(cfg.Name+"."+strings.ToLower("svc.Greeter.SayGoodbye")),
		micro.WithEndpointMetadata(map[string]string{"Description": "TODO: still to be implemented - see .proto file for doco"}),
	)

	logger.Info(
		"registring endpoint",
		slog.Group(
			"endpoint",
			slog.String("subject", cfg.Name+"."+strings.ToLower("svc.Greeter.SaveMetadata")),
		),
	)

	err = srv.AddEndpoint(
		"Greeter",
		micro.ContextHandler(
			ctx,
			func(ctx context.Context, req micro.Request) {
				endpointSubject := cfg.Name + "." + strings.ToLower("svc.Greeter.SaveMetadata")

				ctx, span := tracer.Start(ctx, "SaveMetadata", trace.WithAttributes(attribute.String("subject", endpointSubject)))
				defer span.End()

				hlogger := logger.With(
					slog.Group(
						"endpoint",
						slog.String("subject", endpointSubject),
					),
				)

				r := new(structpb.Struct)

				if err := googleProto.Unmarshal(req.Data(), r); err != nil {
					hlogger.Error("unmarshaling request", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				resp, err := client.SaveMetadata(ctx, r)
				if err != nil {
					hlogger.Error("service error", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				respDump, err := googleProto.Marshal(resp)
				if err != nil {
					hlogger.Error("marshaling response", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}

				if err := req.Respond(respDump); err != nil {
					hlogger.Error("sending response", slog.String("reason", err.Error()))
					handleError(req, err)
					return
				}
			},
		),
		micro.WithEndpointSubject(cfg.Name+"."+strings.ToLower("svc.Greeter.SaveMetadata")),
		micro.WithEndpointMetadata(map[string]string{"Description": "TODO: still to be implemented - see .proto file for doco"}),
	)

	return srv, nil
}

// NATSGreeterClient is a client connecting to a NATS GreeterServer.
type NATSGreeterClient struct {
	nc   *nats.Conn
	name string
}

// NewNATSGreeterClient returns a new GreeterServer client.
// Example:
//
//	nc, err := nats.Connect(ns.ClientURL())
//	if err != nil {
//	  panic(err)
//	}
//
//	client := NewNATSGreeterClient(nc, "example-service-name")
func NewNATSGreeterClient(nc *nats.Conn, name string) *NATSGreeterClient {
	return &NATSGreeterClient{
		nc:   nc,
		name: name,
	}
}

// Sends a greeting
func (c *NATSGreeterClient) SayHello(ctx context.Context, req *HelloRequest) (*HelloReply, error) {
	subject := c.name + "." + strings.ToLower("svc.Greeter.SayHello")

	ctx, span := tracer.Start(ctx, "SayHello", trace.WithAttributes(attribute.String("subject", subject)))
	defer span.End()

	payload, err := googleProto.Marshal(req)
	if err != nil {
		return nil, err
	}

	respPayload, err := c.nc.RequestWithContext(ctx, subject, payload)
	if err != nil {
		return nil, err
	}

	rpcError := respPayload.Header.Get(micro.ErrorHeader)
	if rpcError != "" {
		return nil, errors.New(rpcError)
	}

	resp := new(HelloReply)
	if err := googleProto.Unmarshal(respPayload.Data, resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// Sends another greeting
func (c *NATSGreeterClient) SayHelloAgain(ctx context.Context, req *HelloRequest) (*HelloReply, error) {
	subject := c.name + "." + strings.ToLower("svc.Greeter.SayHelloAgain")

	ctx, span := tracer.Start(ctx, "SayHelloAgain", trace.WithAttributes(attribute.String("subject", subject)))
	defer span.End()

	payload, err := googleProto.Marshal(req)
	if err != nil {
		return nil, err
	}

	respPayload, err := c.nc.RequestWithContext(ctx, subject, payload)
	if err != nil {
		return nil, err
	}

	rpcError := respPayload.Header.Get(micro.ErrorHeader)
	if rpcError != "" {
		return nil, errors.New(rpcError)
	}

	resp := new(HelloReply)
	if err := googleProto.Unmarshal(respPayload.Data, resp); err != nil {
		return nil, err
	}

	return resp, nil
}

func (c *NATSGreeterClient) SayGoodbye(ctx context.Context, req *SayGoodbyeRequest) (*SayGoodbyeReply, error) {
	subject := c.name + "." + strings.ToLower("svc.Greeter.SayGoodbye")

	ctx, span := tracer.Start(ctx, "SayGoodbye", trace.WithAttributes(attribute.String("subject", subject)))
	defer span.End()

	payload, err := googleProto.Marshal(req)
	if err != nil {
		return nil, err
	}

	respPayload, err := c.nc.RequestWithContext(ctx, subject, payload)
	if err != nil {
		return nil, err
	}

	rpcError := respPayload.Header.Get(micro.ErrorHeader)
	if rpcError != "" {
		return nil, errors.New(rpcError)
	}

	resp := new(SayGoodbyeReply)
	if err := googleProto.Unmarshal(respPayload.Data, resp); err != nil {
		return nil, err
	}

	return resp, nil
}

func (c *NATSGreeterClient) SaveMetadata(ctx context.Context, req *structpb.Struct) (*structpb.Struct, error) {
	subject := c.name + "." + strings.ToLower("svc.Greeter.SaveMetadata")

	ctx, span := tracer.Start(ctx, "SaveMetadata", trace.WithAttributes(attribute.String("subject", subject)))
	defer span.End()

	payload, err := googleProto.Marshal(req)
	if err != nil {
		return nil, err
	}

	respPayload, err := c.nc.RequestWithContext(ctx, subject, payload)
	if err != nil {
		return nil, err
	}

	rpcError := respPayload.Header.Get(micro.ErrorHeader)
	if rpcError != "" {
		return nil, errors.New(rpcError)
	}

	resp := new(structpb.Struct)
	if err := googleProto.Unmarshal(respPayload.Data, resp); err != nil {
		return nil, err
	}

	return resp, nil
}
